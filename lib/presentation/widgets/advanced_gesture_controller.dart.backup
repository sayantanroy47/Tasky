import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'dart:math' as math;
import 'glassmorphism_container.dart';
import '../../core/design_system/design_tokens.dart';
import '../../core/theme/typography_constants.dart';
import '../../core/theme/material3/motion_system.dart';

/// Advanced gesture controller with beautiful glassmorphism feedback
class AdvancedGestureController extends StatefulWidget {
  final Widget child;
  final bool enableSwipeActions;
  final bool enableLongPressActions;
  final bool enableMultiTouch;
  final bool enableHoverEffects;
  final VoidCallback? onSwipeLeft;
  final VoidCallback? onSwipeRight;
  final VoidCallback? onSwipeUp;
  final VoidCallback? onSwipeDown;
  final VoidCallback? onLongPress;
  final VoidCallback? onDoubleTap;
  final Function(Offset)? onTap;
  final Function(ScaleUpdateDetails)? onPinch;
  final Duration feedbackDuration;
  
  const AdvancedGestureController({
    super.key,
    required this.child,
    this.enableSwipeActions = true,
    this.enableLongPressActions = true,
    this.enableMultiTouch = true,
    this.enableHoverEffects = true,
    this.onSwipeLeft,
    this.onSwipeRight,
    this.onSwipeUp,
    this.onSwipeDown,
    this.onLongPress,
    this.onDoubleTap,
    this.onTap,
    this.onPinch,
    this.feedbackDuration = const Duration(milliseconds: 300),
  });

  @override
  State<AdvancedGestureController> createState() => _AdvancedGestureControllerState();
}

class _AdvancedGestureControllerState extends State<AdvancedGestureController>
    with TickerProviderStateMixin {
  late AnimationController _feedbackController;
  late AnimationController _rippleController;
  late AnimationController _glowController;
  late AnimationController _swipeController;
  
  late Animation<double> _feedbackAnimation;
  late Animation<double> _rippleAnimation;
  late Animation<double> _glowAnimation;
  late Animation<Offset> _swipeAnimation;
  
  bool _isPressed = false;
  bool _isHovered = false;
  bool _isLongPressed = false;
  Offset _tapPosition = Offset.zero;
  SwipeDirection? _swipeDirection;
  double _swipeProgress = 0.0;
  
  final List<_TouchPoint> _touchPoints = [];

  @override
  void initState() {
    super.initState();
    _setupAnimations();
  }

  void _setupAnimations() {
    _feedbackController = AnimationController(
      duration: widget.feedbackDuration,
      vsync: this,
    );

    _rippleController = AnimationController(
      duration: ExpressiveMotionSystem.durationMedium3,
      vsync: this,
    );

    _glowController = AnimationController(
      duration: ExpressiveMotionSystem.durationLong1,
      vsync: this,
    );

    _swipeController = AnimationController(
      duration: ExpressiveMotionSystem.durationShort4,
      vsync: this,
    );

    _feedbackAnimation = Tween<double>(begin: 1.0, end: 0.95).animate(
      CurvedAnimation(parent: _feedbackController, curve: ExpressiveMotionSystem.standard),
    );

    _rippleAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _rippleController, curve: ExpressiveMotionSystem.emphasizedEasing),
    );

    _glowAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _glowController, curve: Curves.easeInOut),
    );

    _swipeAnimation = Tween<Offset>(begin: Offset.zero, end: Offset.zero).animate(
      CurvedAnimation(parent: _swipeController, curve: ExpressiveMotionSystem.emphasizedDecelerate),
    );
  }

  @override
  void dispose() {
    _feedbackController.dispose();
    _rippleController.dispose();
    _glowController.dispose();
    _swipeController.dispose();
    super.dispose();
  }

  void _handleTapDown(TapDownDetails details) {
    setState(() {
      _isPressed = true;
      _tapPosition = details.localPosition;
    });
    
    _feedbackController.forward();
    HapticFeedback.selectionClick();
  }

  void _handleTapUp(TapUpDetails details) {
    setState(() => _isPressed = false);
    _feedbackController.reverse();
    
    if (widget.onTap != null) {
      widget.onTap!(details.localPosition);
    }
    
    _triggerRipple(details.localPosition);
  }

  void _handleTapCancel() {
    setState(() => _isPressed = false);
    _feedbackController.reverse();
  }

  void _handleLongPressStart(LongPressStartDetails details) {
    if (!widget.enableLongPressActions) return;
    
    setState(() => _isLongPressed = true);
    _glowController.forward();
    HapticFeedback.heavyImpact();
    
    if (widget.onLongPress != null) {
      widget.onLongPress!();
    }
  }

  void _handleLongPressEnd(LongPressEndDetails details) {
    setState(() => _isLongPressed = false);
    _glowController.reverse();
  }

  void _handleDoubleTap() {
    if (widget.onDoubleTap != null) {
      widget.onDoubleTap!();
      HapticFeedback.mediumImpact();
      _triggerSpecialEffect();
    }
  }

  void _handlePanStart(DragStartDetails details) {
    if (!widget.enableSwipeActions) return;
    setState(() {
      _swipeProgress = 0.0;
      _swipeDirection = null;
    });
  }

  void _handlePanUpdate(DragUpdateDetails details) {
    if (!widget.enableSwipeActions) return;
    
    final velocity = details.delta;
    const threshold = 50.0;
    
    SwipeDirection? newDirection;
    double progress = 0.0;
    
    if (velocity.dx.abs() > velocity.dy.abs()) {
      // Horizontal swipe
      if (velocity.dx > threshold) {
        newDirection = SwipeDirection.right;
        progress = (velocity.dx / 200).clamp(0.0, 1.0);
      } else if (velocity.dx < -threshold) {
        newDirection = SwipeDirection.left;
        progress = (velocity.dx.abs() / 200).clamp(0.0, 1.0);
      }
    } else {
      // Vertical swipe
      if (velocity.dy > threshold) {
        newDirection = SwipeDirection.down;
        progress = (velocity.dy / 200).clamp(0.0, 1.0);
      } else if (velocity.dy < -threshold) {
        newDirection = SwipeDirection.up;
        progress = (velocity.dy.abs() / 200).clamp(0.0, 1.0);
      }
    }
    
    setState(() {
      _swipeDirection = newDirection;
      _swipeProgress = progress;
    });
    
    _updateSwipeAnimation();
  }

  void _handlePanEnd(DragEndDetails details) {
    if (!widget.enableSwipeActions || _swipeDirection == null) return;
    
    if (_swipeProgress > 0.5) {
      _executeSwipe();
    }
    
    setState(() {
      _swipeDirection = null;
      _swipeProgress = 0.0;
    });
    
    _swipeController.reverse();
  }

  void _handleScaleUpdate(ScaleUpdateDetails details) {
    if (!widget.enableMultiTouch || widget.onPinch == null) return;
    
    widget.onPinch!(details);
    
    // Add touch points visualization
    _updateTouchPoints(details);
  }

  void _handleHover(PointerHoverEvent event) {
    if (!widget.enableHoverEffects) return;
    
    setState(() => _isHovered = true);
  }

  void _handleExit(PointerExitEvent event) {
    setState(() => _isHovered = false);
  }

  void _triggerRipple(Offset position) {
    setState(() => _tapPosition = position);
    _rippleController.forward().then((_) => _rippleController.reset());
  }

  void _triggerSpecialEffect() {
    // Double tap creates a special glass shatter effect
    HapticFeedback.heavyImpact();
    _glowController.forward().then((_) => _glowController.reverse());
  }

  void _updateSwipeAnimation() {
    if (_swipeDirection == null) return;
    
    Offset target = Offset.zero;
    switch (_swipeDirection!) {
      case SwipeDirection.left:
        target = Offset(-_swipeProgress * 50, 0);
        break;
      case SwipeDirection.right:
        target = Offset(_swipeProgress * 50, 0);
        break;
      case SwipeDirection.up:
        target = Offset(0, -_swipeProgress * 50);
        break;
      case SwipeDirection.down:
        target = Offset(0, _swipeProgress * 50);
        break;
    }
    
    _swipeAnimation = Tween<Offset>(
      begin: _swipeAnimation.value,
      end: target,
    ).animate(_swipeController);
    
    _swipeController.forward();
  }

  void _executeSwipe() {
    HapticFeedback.mediumImpact();
    
    switch (_swipeDirection!) {
      case SwipeDirection.left:
        widget.onSwipeLeft?.call();
        break;
      case SwipeDirection.right:
        widget.onSwipeRight?.call();
        break;
      case SwipeDirection.up:
        widget.onSwipeUp?.call();
        break;
      case SwipeDirection.down:
        widget.onSwipeDown?.call();
        break;
    }
  }

  void _updateTouchPoints(ScaleUpdateDetails details) {
    // Simulate multi-touch visualization
    _touchPoints.clear();
    
    // Add main touch point
    _touchPoints.add(_TouchPoint(
      position: details.localFocalPoint,
      intensity: details.scale.clamp(0.5, 2.0),
    ));
    
    // Add secondary touch points for pinch gesture
    if (details.scale != 1.0) {
      final angle = math.atan2(details.localFocalPoint.dy, details.localFocalPoint.dx);
      final distance = 50 * details.scale;
      
      _touchPoints.add(_TouchPoint(
        position: details.localFocalPoint + Offset(
          math.cos(angle) * distance,
          math.sin(angle) * distance,
        ),
        intensity: details.scale.clamp(0.5, 2.0),
      ));
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return MouseRegion(
      onHover: _handleHover,
      onExit: _handleExit,
      child: GestureDetector(
        onTapDown: _handleTapDown,
        onTapUp: _handleTapUp,
        onTapCancel: _handleTapCancel,
        onLongPressStart: _handleLongPressStart,
        onLongPressEnd: _handleLongPressEnd,
        onDoubleTap: _handleDoubleTap,
        onPanStart: _handlePanStart,
        onPanUpdate: _handlePanUpdate,
        onPanEnd: _handlePanEnd,
        onScaleUpdate: _handleScaleUpdate,
        child: AnimatedBuilder(
          animation: Listenable.merge([
            _feedbackAnimation,
            _rippleAnimation,
            _glowAnimation,
            _swipeAnimation,
          ]),
          builder: (context, child) {
            return Stack(
              clipBehavior: Clip.none,
              children: [
                // Main content with transformations
                Transform.scale(
                  scale: _feedbackAnimation.value,
                  child: Transform.translate(
                    offset: _swipeAnimation.value,
                    child: _buildEnhancedContainer(theme),
                  ),
                ),
                
                // Ripple effect
                if (_rippleAnimation.value > 0)
                  Positioned.fill(
                    child: CustomPaint(
                      painter: _GlassRipplePainter(
                        center: _tapPosition,
                        progress: _rippleAnimation.value,
                        color: theme.colorScheme.primary.withValues(alpha: 0.3),
                      ),
                    ),
                  ),
                
                // Glow effect for long press
                if (_glowAnimation.value > 0)
                  Positioned.fill(
                    child: Container(
                      decoration: BoxDecoration(
                        borderRadius: BorderRadius.circular(TypographyConstants.radiusSmall),
                        boxShadow: [
                          BoxShadow(
                            color: theme.colorScheme.primary.withValues(alpha: 
                              0.4 * _glowAnimation.value,
                            ),
                            blurRadius: 20 * _glowAnimation.value,
                            spreadRadius: 5 * _glowAnimation.value,
                          ),
                        ],
                      ),
                    ),
                  ),
                
                // Swipe direction indicator
                if (_swipeDirection != null && _swipeProgress > 0.2)
                  _buildSwipeIndicator(theme),
                
                // Multi-touch visualization
                ..._touchPoints.map((point) => _buildTouchPoint(theme, point)),
              ],
            );
          },
        ),
      ),
    );
  }

  Widget _buildEnhancedContainer(ThemeData theme) {
    double glassIntensity = 1.0;
    
    if (_isHovered) glassIntensity += 0.2;
    if (_isPressed) glassIntensity += 0.3;
    if (_isLongPressed) glassIntensity += 0.5;
    
    return GlassmorphismContainer(
      level: GlassLevel.interactive,
      borderRadius: BorderRadius.circular(TypographyConstants.radiusSmall),
      glassTint: theme.colorScheme.primary.withValues(alpha: 0.1 * glassIntensity),
      child: widget.child,
    );
  }

  Widget _buildSwipeIndicator(ThemeData theme) {
    IconData icon;
    Color color;
    
    switch (_swipeDirection!) {
      case SwipeDirection.left:
        icon = Icons.arrow_back;
        color = Colors.red;
        break;
      case SwipeDirection.right:
        icon = Icons.arrow_forward;
        color = Colors.green;
        break;
      case SwipeDirection.up:
        icon = Icons.keyboard_arrow_up;
        color = Colors.blue;
        break;
      case SwipeDirection.down:
        icon = Icons.keyboard_arrow_down;
        color = Colors.orange;
        break;
    }
    
    return Center(
      child: GlassmorphismContainer(
        level: GlassLevel.floating,
        width: 60,
        height: 60,
        borderRadius: BorderRadius.circular(30),
        glassTint: color.withValues(alpha: 0.3),
        child: Icon(
          icon,
          color: color,
          size: 30,
        ),
      ),
    );
  }

  Widget _buildTouchPoint(ThemeData theme, _TouchPoint point) {
    return Positioned(
      left: point.position.dx - 15,
      top: point.position.dy - 15,
      child: Container(
        width: 30,
        height: 30,
        decoration: BoxDecoration(
          shape: BoxShape.circle,
          color: theme.colorScheme.primary.withValues(alpha: 0.3),
          border: Border.all(
            color: theme.colorScheme.primary,
            width: 2,
          ),
        ),
      ),
    );
  }
}

/// Custom painter for glass ripple effect
class _GlassRipplePainter extends CustomPainter {
  final Offset center;
  final double progress;
  final Color color;

  _GlassRipplePainter({
    required this.center,
    required this.progress,
    required this.color,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final maxRadius = math.sqrt(size.width * size.width + size.height * size.height);
    final radius = maxRadius * progress;
    
    final paint = Paint()
      ..color = color.withValues(alpha: (1.0 - progress) * 0.5)
      ..style = PaintingStyle.fill;

    // Draw expanding circle with glassmorphism effect
    canvas.drawCircle(center, radius, paint);
    
    // Draw ring effect
    final ringPaint = Paint()
      ..color = color.withValues(alpha: (1.0 - progress) * 0.8)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 3.0;
    
    canvas.drawCircle(center, radius * 0.8, ringPaint);
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}

/// Touch point data class
class _TouchPoint {
  final Offset position;
  final double intensity;

  _TouchPoint({
    required this.position,
    required this.intensity,
  });
}

/// Swipe direction enumeration
enum SwipeDirection {
  left,
  right,
  up,
  down,
}