import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import '../../domain/models/enums.dart';
import '../../core/theme/material3/motion_system.dart';
import '../../core/theme/typography_constants.dart';

/// Animated priority chip with pulsing colors and effects
/// Different priorities have different animation speeds and intensities
class PulsingPriorityChip extends StatefulWidget {
  final TaskPriority priority;
  final String? customText;
  final double? width;
  final double? height;
  final VoidCallback? onTap;
  final bool enabled;
  final bool showPulse;
  final double scale;

  const PulsingPriorityChip({
    super.key,
    required this.priority,
    this.customText,
    this.width,
    this.height,
    this.onTap,
    this.enabled = true,
    this.showPulse = true,
    this.scale = 1.0,
  });

  @override
  State<PulsingPriorityChip> createState() => _PulsingPriorityChipState();
}

class _PulsingPriorityChipState extends State<PulsingPriorityChip>
    with TickerProviderStateMixin {
  late AnimationController _pulseController;
  late AnimationController _pressController;
  late AnimationController _glowController;
  
  late Animation<double> _pulseAnimation;
  late Animation<double> _pressAnimation;
  late Animation<double> _glowAnimation;
  // late Animation<Color?> _colorAnimation;

  @override
  void initState() {
    super.initState();
    _setupAnimations();
    if (widget.showPulse && widget.enabled) {
      _startPulseAnimation();
    }
  }

  @override
  void didUpdateWidget(PulsingPriorityChip oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.showPulse != oldWidget.showPulse || 
        widget.enabled != oldWidget.enabled ||
        widget.priority != oldWidget.priority) {
      if (widget.showPulse && widget.enabled) {
        _startPulseAnimation();
      } else {
        _stopPulseAnimation();
      }
    }
  }

  void _setupAnimations() {
    // Pulse animation with priority-specific duration
    _pulseController = AnimationController(
      duration: _getPulseDuration(),
      vsync: this,
    );

    // Press animation for interactions
    _pressController = AnimationController(
      duration: ExpressiveMotionSystem.durationShort3,
      vsync: this,
    );

    // Glow animation for emphasis
    _glowController = AnimationController(
      duration: ExpressiveMotionSystem.durationMedium2,
      vsync: this,
    );

    // Pulse animation (color intensity and scale)
    _pulseAnimation = Tween<double>(
      begin: 0.7,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _pulseController,
      curve: ExpressiveMotionSystem.emphasizedEasing,
    ));

    // Press animation (scale down on tap)
    _pressAnimation = Tween<double>(
      begin: 1.0,
      end: 0.95,
    ).animate(CurvedAnimation(
      parent: _pressController,
      curve: ExpressiveMotionSystem.emphasizedDecelerate,
    ));

    // Glow animation (opacity)
    _glowAnimation = Tween<double>(
      begin: 0.0,
      end: 0.3,
    ).animate(CurvedAnimation(
      parent: _glowController,
      curve: ExpressiveMotionSystem.standard,
    ));

    // Color animation for smooth priority changes
    // _colorAnimation = ColorTween(
    //   begin: _getPriorityColor(),
    //   end: _getPriorityColor(),
    // ).animate(_pulseController);
  }

  Duration _getPulseDuration() {
    switch (widget.priority) {
      case TaskPriority.urgent:
        return const Duration(milliseconds: 800); // Fast pulse
      case TaskPriority.high:
        return const Duration(milliseconds: 1200); // Medium pulse
      case TaskPriority.medium:
        return const Duration(milliseconds: 1800); // Slow pulse
      case TaskPriority.low:
        return const Duration(milliseconds: 2500); // Very slow pulse
    }
  }

  Color _getPriorityColor() {
    switch (widget.priority) {
      case TaskPriority.urgent:
        return Colors.deepPurple;
      case TaskPriority.high:
        return Colors.red;
      case TaskPriority.medium:
        return Colors.orange;
      case TaskPriority.low:
        return Colors.blue;
    }
  }

  double _getPulseIntensity() {
    switch (widget.priority) {
      case TaskPriority.urgent:
        return 0.4; // High intensity
      case TaskPriority.high:
        return 0.3; // Medium-high intensity
      case TaskPriority.medium:
        return 0.2; // Medium intensity
      case TaskPriority.low:
        return 0.1; // Low intensity
    }
  }

  String _getPriorityText() {
    return widget.customText ?? widget.priority.displayName.toUpperCase();
  }

  void _startPulseAnimation() {
    _pulseController.repeat(reverse: true);
    if (widget.priority == TaskPriority.urgent) {
      _glowController.repeat(reverse: true);
    }
  }

  void _stopPulseAnimation() {
    _pulseController.stop();
    _glowController.stop();
  }

  void _onTapDown(TapDownDetails details) {
    if (widget.enabled) {
      _pressController.forward();
      HapticFeedback.selectionClick();
    }
  }

  void _onTapUp(TapUpDetails details) {
    if (widget.enabled) {
      _pressController.reverse();
    }
  }

  void _onTapCancel() {
    if (widget.enabled) {
      _pressController.reverse();
    }
  }

  void _onTap() {
    if (widget.enabled && widget.onTap != null) {
      HapticFeedback.mediumImpact();
      widget.onTap!();
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return Transform.scale(
      scale: widget.scale,
      child: AnimatedBuilder(
        animation: Listenable.merge([
          _pulseAnimation,
          _pressAnimation,
          _glowAnimation,
        ]),
        builder: (context, child) {
          final baseColor = _getPriorityColor();
          final pulseIntensity = _getPulseIntensity();
          final pulseValue = widget.showPulse && widget.enabled ? _pulseAnimation.value : 1.0;
          
          // Calculate pulsing color
          final currentColor = Color.lerp(
            baseColor.withValues(alpha: 0.6),
            baseColor,
            pulseValue,
          ) ?? baseColor;

          return GestureDetector(
            onTapDown: _onTapDown,
            onTapUp: _onTapUp,
            onTapCancel: _onTapCancel,
            onTap: _onTap,
            child: Transform.scale(
              scale: _pressAnimation.value,
              child: Container(
                width: widget.width,
                height: widget.height,
                padding: const EdgeInsets.symmetric(
                  horizontal: 12,
                  vertical: 6,
                ),
                decoration: BoxDecoration(
                  color: currentColor,
                  borderRadius: BorderRadius.circular(TypographyConstants.chipRadius),
                  border: Border.all(
                    color: currentColor.withValues(alpha: 0.3),
                    width: 1,
                  ),
                  boxShadow: widget.enabled && widget.showPulse ? [
                    BoxShadow(
                      color: currentColor.withValues(alpha: _glowAnimation.value * pulseIntensity),
                      blurRadius: 8 + (_glowAnimation.value * 4),
                      spreadRadius: 2 + (_glowAnimation.value * 2),
                    ),
                    if (widget.priority == TaskPriority.urgent)
                      BoxShadow(
                        color: currentColor.withValues(alpha: _glowAnimation.value * 0.2),
                        blurRadius: 16,
                        spreadRadius: 4,
                      ),
                  ] : [
                    BoxShadow(
                      color: theme.shadowColor.withValues(alpha: 0.1),
                      blurRadius: 2,
                      offset: const Offset(0, 1),
                    ),
                  ],
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                      _getPriorityIcon(),
                      size: 14,
                      color: _getTextColor(currentColor),
                    ),
                    const SizedBox(width: 4),
                    Text(
                      _getPriorityText(),
                      style: theme.textTheme.labelSmall?.copyWith(
                        color: _getTextColor(currentColor),
                        fontWeight: FontWeight.w600,
                        letterSpacing: 0.5,
                      ),
                    ),
                  ],
                ),
              ),
            ),
          );
        },
      ),
    );
  }

  IconData _getPriorityIcon() {
    switch (widget.priority) {
      case TaskPriority.urgent:
        return Icons.priority_high;
      case TaskPriority.high:
        return Icons.keyboard_arrow_up;
      case TaskPriority.medium:
        return Icons.remove;
      case TaskPriority.low:
        return Icons.keyboard_arrow_down;
    }
  }

  Color _getTextColor(Color backgroundColor) {
    // Calculate contrast and return appropriate text color
    final luminance = backgroundColor.computeLuminance();
    return luminance > 0.5 ? Colors.black87 : Colors.white;
  }

  @override
  void dispose() {
    _pulseController.dispose();
    _pressController.dispose();
    _glowController.dispose();
    super.dispose();
  }
}

/// Compact version of the priority chip for small spaces
class CompactPriorityChip extends StatelessWidget {
  final TaskPriority priority;
  final VoidCallback? onTap;
  final double size;
  final bool showPulse;

  const CompactPriorityChip({
    super.key,
    required this.priority,
    this.onTap,
    this.size = 24,
    this.showPulse = true,
  });

  @override
  Widget build(BuildContext context) {
    return PulsingPriorityChip(
      priority: priority,
      customText: '',
      width: size,
      height: size,
      onTap: onTap,
      showPulse: showPulse,
      scale: 0.8,
    );
  }
}

/// Priority chip with custom styling for different contexts
class StyledPriorityChip extends StatelessWidget {
  final TaskPriority priority;
  final PriorityChipStyle style;
  final VoidCallback? onTap;
  final bool showPulse;

  const StyledPriorityChip({
    super.key,
    required this.priority,
    required this.style,
    this.onTap,
    this.showPulse = true,
  });

  @override
  Widget build(BuildContext context) {
    switch (style) {
      case PriorityChipStyle.filled:
        return PulsingPriorityChip(
          priority: priority,
          onTap: onTap,
          showPulse: showPulse,
        );
      case PriorityChipStyle.outlined:
        return _OutlinedPriorityChip(
          priority: priority,
          onTap: onTap,
          showPulse: showPulse,
        );
      case PriorityChipStyle.minimal:
        return _MinimalPriorityChip(
          priority: priority,
          onTap: onTap,
          showPulse: showPulse,
        );
    }
  }
}

class _OutlinedPriorityChip extends StatelessWidget {
  final TaskPriority priority;
  final VoidCallback? onTap;
  final bool showPulse;

  const _OutlinedPriorityChip({
    required this.priority,
    this.onTap,
    this.showPulse = true,
  });

  @override
  Widget build(BuildContext context) {
    // Implementation for outlined style
    return PulsingPriorityChip(
      priority: priority,
      onTap: onTap,
      showPulse: showPulse,
    );
  }
}

class _MinimalPriorityChip extends StatelessWidget {
  final TaskPriority priority;
  final VoidCallback? onTap;
  final bool showPulse;

  const _MinimalPriorityChip({
    required this.priority,
    this.onTap,
    this.showPulse = true,
  });

  @override
  Widget build(BuildContext context) {
    // Implementation for minimal style
    return PulsingPriorityChip(
      priority: priority,
      onTap: onTap,
      showPulse: showPulse,
      scale: 0.9,
    );
  }
}

enum PriorityChipStyle {
  filled,
  outlined,
  minimal,
}